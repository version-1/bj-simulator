package strategy

import (
	"version-1/bj-simulator/internal/card"
	"version-1/bj-simulator/internal/config"
	"version-1/bj-simulator/internal/player"
)

type Basic struct{}

func (m Martingale) Act(c config.Config, myself player.Player, players []player.Player, dealer player.Dealer) player.Act {
	dh := card.Hands(dealer.CurrentRound().Hands)
	mh := card.Hands(myself.CurrentRound().Hands)

	dsum, _, _ := dh.Sum()
	msum, _, _ := mh.Sum()

	if mh.CanSplit() {
		return softHandsWithPair[msum][dsum]
	}

	return softHands[msum][dsum]
}

var softHands = map[int][]player.Act{
	3: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	4: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	5: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	6: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	7: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	8: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	9: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	10: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	11: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	12: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	13: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	14: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	15: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	16: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	17: {
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
	},
	18: {
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
	},
	19: {
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
	},
	20: {
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
	},
	21: {
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
	},
}

var softHandsWithPair = map[int][]player.Act{
	2: {
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
	},
	4: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	6: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	8: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	10: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	12: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	14: {
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
		player.Hit(),
	},
	16: {
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
		player.Split(),
	},
	18: {
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
	},
	20: {
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
		player.Stand(),
	},
}

type Dealer struct{}

func (m Martingale) Delaer(c config.Config, myself player.Player, players []player.Player, dealer player.Dealer) player.Act {
	mh := card.Hands(myself.Hands)
	msum, _, _ := mh.Sum()

	if msum <= 16 {
		return player.Hit()
	}

	return player.Stand()
}
